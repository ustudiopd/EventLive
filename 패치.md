좋아. **“최소 패치”**로 딱 2가지만 고칠게(너가 요청한 포인트 그대로):

1. **Highlights의 evidenceIds가 분포(E1,E3)로만 붙는 문제** → *교차표(E4~E6) 우선으로 정확히 연결 + fallback 개선*
2. **LeadQueue가 역할 추정 실패/불완전해도 항상 생성되는 문제** → *timeframe + followup_intent가 있을 때만 생성*

아래는 **`buildAnalysisPack.ts` 한 파일만 수정**하면 되는 패치야.

---

# ✅ 패치 대상 파일

`/lib/surveys/analysis/buildAnalysisPack.ts`

---

# 1) LeadQueue “조건부 생성” 패치

## (A) 기존 8번 블록 교체

기존:

```ts
// 8. 리드 신호 생성 (태그가 있을 때만)
const leadSignals = buildLeadSignals(
  questionsWithRole,
  answersArray,
  submissionsArray
)
```

⬇️ 아래로 교체:

```ts
// 8. 리드 신호 생성 (조건 충족 시에만 생성: timeframe + followup_intent 필요)
const timingQuestion = questionsWithRole.find((q) => q.role === 'timeframe')
const followupQuestion = questionsWithRole.find((q) => q.role === 'followup_intent')

// 최소 조건: timeframe + followup_intent가 서로 다른 문항으로 존재
const leadScoringEnabled = Boolean(
  timingQuestion &&
    followupQuestion &&
    timingQuestion.id !== followupQuestion.id
)

const leadSignals = leadScoringEnabled
  ? buildLeadSignals(questionsWithRole, answersArray, submissionsArray)
  : {
      distribution: [],
      channelPreference: {},
      timingDistribution: {},
      leadQueue: [],
    }
```

## (B) 기존 12번 LeadQueue 블록 교체

기존:

```ts
// 12. Lead Queue 생성 (태그가 있을 때만)
const leadQueue = leadSignals.distribution.length > 0
  ? {
      distribution: leadSignals.distribution.map((dist) => ({
        tier: dist.tier as 'P0' | 'P1' | 'P2' | 'P3' | 'P4',
        count: dist.count,
        pct: dist.pct,
      })),
    }
  : undefined
```

⬇️ 아래로 교체:

```ts
// 12. Lead Queue 생성 (leadScoringEnabled 일 때만)
const leadQueue =
  leadScoringEnabled && leadSignals.distribution.length > 0
    ? {
        distribution: leadSignals.distribution.map((dist) => ({
          tier: dist.tier as 'P0' | 'P1' | 'P2' | 'P3' | 'P4',
          count: dist.count,
          pct: dist.pct,
        })),
      }
    : undefined
```

✅ 효과

* 문항이 바뀌어서 **followup/timeframe을 못 찾으면 리드 분포 자체가 사라짐**(불필요한 P3/P4만 찍히는 상황 방지)
* 문항이 있어야만 리드 스코어 생성 → **운영/신뢰성 개선**

---

# 2) Highlights evidenceIds “교차표 우선 + 정확 매칭” 패치

지금 너가 올린 12/28 MD에서 H1~H3 근거가 **E1, E3**로만 붙어있는데,
사실 같은 문서 안에 **E4/E5/E6(교차표)**가 있는데도 못 붙고 있어.
이건 LLM 고도화 단계에서 “근거 링크가 틀린 보고서”로 이어질 수 있어.

## buildHighlights 함수 통째로 교체

파일 맨 아래 `function buildHighlights(...)`를 **아래 코드로 통째로 교체**해줘:

```ts
/**
 * Highlights 생성
 * 교차표 하이라이트를 Evidence Catalog와 연결
 *
 * ✅ 개선 포인트
 * - 교차표 기반 Evidence(metric/source) 우선 연결
 * - 고정 fallback(E1,E2) 제거 → 실제 존재하는 Evidence로 fallback
 * - statement 내 셀 표본(n/rowTotal)을 이용해 과도한 Confirmed 라벨을 Directional/Hypothesis로 보정
 * - (가능하면) statement의 lift/분자/분모를 Evidence notes/valueText와 매칭해 “해당 하이라이트”에 가장 가까운 Evidence를 우선 연결
 */
function buildHighlights(
  crosstabHighlights: Array<{
    rowQuestionBody: string
    colQuestionBody: string
    highlight: string
    confidence?: 'Confirmed' | 'Directional' | 'Hypothesis'
  }>,
  evidenceCatalog: Array<{
    id: string
    title: string
    metric?: string
    source?: string
    valueText?: string
    notes?: string
  }>
): Array<{
  id: string
  title: string
  evidenceIds: string[]
  statement: string
  confidence: 'Confirmed' | 'Directional' | 'Hypothesis'
}> {
  const fallbackIds = evidenceCatalog.slice(0, 2).map((e) => e.id)

  const inferConfidence = (
    statement: string,
    provided?: 'Confirmed' | 'Directional' | 'Hypothesis'
  ): 'Confirmed' | 'Directional' | 'Hypothesis' => {
    let confidence: 'Confirmed' | 'Directional' | 'Hypothesis' = provided || 'Directional'

    // 예: "(lift 1.36, 6/17)" 같은 패턴에서 셀 표본(6) 추출
    const m = statement.match(/[,\\(]\\s*(\\d+)\\s*\\/\\s*(\\d+)\\s*\\)?/)
    if (m) {
      const cellN = parseInt(m[1], 10)
      if (!Number.isNaN(cellN)) {
        if (cellN < 5) return 'Hypothesis'
        if (cellN < 10 && confidence === 'Confirmed') return 'Directional'
      }
    }
    return confidence
  }

  const uniq = (arr: string[]) => Array.from(new Set(arr))

  const extractTokens = (statement: string) => {
    const ratio = statement.match(/(\\d+)\\s*\\/\\s*(\\d+)/)
    const lift = statement.match(/lift\\s*([0-9]+(?:\\.[0-9]+)?)/i)
    return {
      ratioText: ratio ? `${ratio[1]}/${ratio[2]}` : null,
      liftText: lift ? lift[1] : null,
    }
  }

  const isCrosstabEvidence = (e: { title: string; metric?: string; source?: string }) =>
    e.metric === '교차표' ||
    e.source === 'crosstab' ||
    e.title.includes('교차표') ||
    e.title.includes('교차') ||
    e.title.includes('×')

  const getHaystack = (e: { title: string; valueText?: string; notes?: string }) =>
    `${e.title} ${e.valueText ?? ''} ${e.notes ?? ''}`

  return crosstabHighlights.map((h, index) => {
    const row = h.rowQuestionBody
    const col = h.colQuestionBody
    const { ratioText, liftText } = extractTokens(h.highlight)

    // 1) 교차표 Evidence 후보를 점수화해서 “해당 하이라이트에 가장 가까운 Evidence”를 먼저 선택
    const crosstabRanked = evidenceCatalog
      .filter((e) => isCrosstabEvidence(e))
      .map((e) => {
        const hay = getHaystack(e)
        let score = 0
        if (hay.includes(row) && hay.includes(col)) score += 3
        else if (hay.includes(row) || hay.includes(col)) score += 1
        if (ratioText && hay.includes(ratioText)) score += 10
        if (liftText && hay.includes(liftText)) score += 8
        return { id: e.id, score }
      })
      .sort((a, b) => b.score - a.score)
      .map((x) => x.id)

    const bestCrosstabId = crosstabRanked[0]

    // 2) 보조 Evidence: row/col 분포(있으면) 1개 붙이기
    const distRanked = evidenceCatalog
      .filter((e) => e.metric === '분포')
      .map((e) => {
        const hay = getHaystack(e)
        let score = 0
        if (hay.includes(row)) score += 2
        if (hay.includes(col)) score += 2
        return { id: e.id, score }
      })
      .sort((a, b) => b.score - a.score)
      .map((x) => x.id)

    const combined = uniq([
      ...(bestCrosstabId ? [bestCrosstabId] : []),
      ...distRanked,
      ...crosstabRanked.slice(1),
    ]).slice(0, 2)

    const evidenceIds =
      combined.length >= 2 ? combined : uniq([...combined, ...fallbackIds]).slice(0, 2)

    return {
      id: `H${index + 1}`,
      title: `${row} × ${col} 교차 분석`,
      evidenceIds,
      statement: h.highlight,
      confidence: inferConfidence(h.highlight, h.confidence),
    }
  })
}
```

✅ 효과

* 너가 올린 케이스처럼 **H1/H2/H3가 “E1,E3”가 아니라 “E4/E5/E6” 중 해당하는 걸 우선 연결**하게 됨

  * `(lift 1.48, 5/13)` → E4
  * `(lift 1.36, 6/17)` → E5
  * `(lift 1.05, 5/17)` → E6
* 그리고 셀 표본이 5~6이면 **‘✅ 확정’(Confirmed)을 자동으로 ‘⚠️ 방향성’으로 다운그레이드**해서 더 전문적으로 보임

---

# 적용 후 “바로 확인해야 할 결과”

너가 올린 12/28 결과 기준으로는, 패치 후 다음이 보여야 정상:

* **H1 근거**: `E4 + (E1 or E3 중 하나)` 형태
* **H2 근거**: `E5 + (E1 or E3)`
* **H3 근거**: `E6 + (E1 or E3)`
* **신뢰도**: 5/13, 6/17, 5/17 같은 셀은 **✅확정이 아니라 ⚠️방향성**으로 바뀌는 게 정상
* **리드 우선순위 분포**는 timeframe+followup이 없으면 아예 섹션이 안 나와야 정상

---

원하면 다음 단계로, **딱 1줄 추가로** “리드 우선순위(E7/E8 같은 Evidence)”도 **leadScoringEnabled=false면 EvidenceCatalog에 포함되지 않게**(완전 깔끔하게)까지 정리해줄게.
하지만 지금 요청한 “최소 패치” 범위에서는 위 2개만으로도 체감 개선이 꽤 클 거야.
