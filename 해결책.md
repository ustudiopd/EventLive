문제 재현 로그를 보면

* **SUBSCRIBED 직후 바로 CLOSED** 상태가 찍히고,
* 그 뒤 **폴백 폴링**으로 새 메시지를 가져와서 **10~15초 지연**이 생깁니다.

올려주신 코드들을 보면, 이 현상이 나는 **구조적 원인**이 분명합니다. 아래를 순서대로 정리해 드릴게요.

---

## 핵심 원인

### 1) 구독(useEffect) 재실행 → 의도치 않은 `CLOSED` → 재시도 카운팅

`Chat.tsx`에서 실시간 구독을 세팅하는 `useEffect`의 의존성에 **`currentUser?.id`**가 포함되어 있습니다:

```ts
useEffect(() => {
  // ...
  // 실시간 구독 설정
  setupRealtimeSubscription()
  return () => {
    // cleanup에서 unsubscribe + removeChannel
  }
}, [webinarId, currentUser?.id, reconnectKey])
```

* 초기에 `currentUser`가 **null → 사용자 ID로 갱신**되면, 이 이펙트가 **다시 실행**되며 **기존 채널을 `unsubscribe()`**합니다.
* 이때 Phoenix 채널 상태 콜백에 **`status: 'CLOSED'`**가 정상적으로 전달되는데, 현재 코드는 이를 **실패로 간주하여 `reconnectTriesRef`를 증가**시키고, 3회 누적 시 **폴백 모드로 전환**합니다. 

즉, *“성공했다가 바로 해제하면서 실패가 뜨는”* 건 **맞습니다**. 코드가 그렇게 동작하게 되어 있습니다.

### 2) “이벤트 없음 ⇒ 폴백” 헬스체크가 과민함

별도의 헬스체크 타이머에서 **“N초 동안 이벤트가 없으면 폴백 활성화”** 로직을 돌립니다. 현재 배포본은 로그상 **10초**, 최신 코드엔 **3초** 기준으로 보입니다. 문제는 **이벤트가 없다는 것만으로는 연결이 죽었다고 볼 수 없는데도 폴백을 켜버린다**는 점입니다. 실시간으로 주고받을 이벤트가 잠시 없기만 해도 곧장 폴백을 켭니다. 결국 폴링으로 메시지를 받게 되어 체감 지연이 **10~15초**가 됩니다. 

### 3) 폴백 폴링에서 **ETag**를 증분 조회에도 적용

폴백에서 **`after=lastMessageId`**로 “증분만” 가져오는데도 `If-None-Match`(ETag)를 그대로 보냅니다. 서버가 쿼리 스트링을 포함한 정확한 단위로 ETag를 계산하지 않으면, **실제로는 새로운 레코드가 있어도 304**가 떨어질 수 있어, 다음 폴 주기까지 **추가 지연**이 생깁니다. 증분 조회에는 ETag를 빼는 쪽이 안전합니다. 

### 4) 구독 중복/경합 가능성

새 채널을 만들기 전에 `getChannels()`로 기존 채널을 찾아 **`unsubscribe()` 후 `removeChannel()`** 하는데, **설정 중 경합**(isSettingUpRef 플래그로 방어하긴 했지만)이나 **클린업 타이밍**에 따라 방금 붙은 채널을 곧장 닫아버리는 경우가 생길 수 있습니다. 이때도 `status: 'CLOSED'`가 “실패”로 집계됩니다. 

> 서버 쪽 브로드캐스트 코드는 정상입니다. 매 호출마다 관리 키로 클라이언트를 만들고 채널에 `subscribe()` 한 뒤 `channel.send({type:'broadcast', ...})`로 쏩니다. 이 부분은 클라이언트의 지연 문제와 무관합니다. 

---

## 바로 적용 가능한 수정안 (안전도/효과 순)

### A. `CLOSED`를 **실패로 세지 않기** (수동 해제 구분)

* `cleanup`로 **우리가 직접** `unsubscribe()` 하는 케이스의 `CLOSED`는 **정상 종료**입니다. 실패 카운팅에서 제외하세요.

```ts
const manualCloseRef = useRef(false);

// cleanup 직전
manualCloseRef.current = true;
await currentChannel.unsubscribe();
supabase.removeChannel(currentChannel);
manualCloseRef.current = false;

// 구독 콜백
.subscribe((status, err) => {
  if (status === 'CLOSED' && (!err || manualCloseRef.current)) {
    // 정상/수동 종료: 실패로 간주하지 않음
    return;
  }
  if (['CHANNEL_ERROR','TIMED_OUT'].includes(status)) {
    reconnectTriesRef.current++;
    // ... (이하 동일)
  }
})
```

> 이렇게 하면 **“SUBSCRIBED → (정상 cleanup) → CLOSED”**가 더 이상 실패로 누적되지 않습니다. 

### B. 구독 이펙트 의존성에서 **`currentUser?.id` 제거**

* 현재 `presence: { key: currentUser.id }` 때문에 `currentUser?.id`를 의존성에 올려놨는데, 그 탓에 **사용자 로딩 완료 시 매번 재구독**이 발생합니다.
* 채팅만 본다면 presence는 **필수 아님**이므로 **우선 제거**하거나,
* 존재하더라도 **채널을 재생성하지 말고** `SUBSCRIBED` 이후 `channel.track({ ... })`로 **나중에 트래킹**하세요.

```ts
useEffect(() => {
  setupRealtimeSubscription(); // presence 없이
  return cleanup;
}, [webinarId, reconnectKey]); // ✅ currentUser?.id 제거
```

> 이 한 가지만으로도 **의도치 않은 `CLOSED` 빈도**가 확 줄고, 폴백으로 밀려나는 일이 크게 줄어듭니다. 

### C. 헬스체크 조건을 **“이벤트 부재” → “채널 상태”**로 바꾸기

* 지금은 **3~10초 동안 이벤트가 없으면** 폴백을 켜는데, 연결이 멀쩡해도 폴백이 켜집니다.
* 대신 **채널 상태**로 판단하세요. Phoenix/Supabase 채널은 `channelRef.current.state`가 있습니다. **`'joined'`가 아니거나** 에러/타임아웃이 **연속으로 N회 발생**할 때만 폴백을 켭니다.

```ts
useEffect(() => {
  const id = setInterval(() => {
    const joined = channelRef.current?.state === 'joined';
    if (!joined && !fallbackOn) setFallbackOn(true);
  }, 3000);
  return () => clearInterval(id);
}, [fallbackOn]);
```

> 이렇게 하면 *“그냥 조용한 시간대”* 때문에 폴백이 켜지는 걸 막을 수 있습니다. 

### D. 폴백 폴링에서 **증분(after) 요청에는 ETag를 제거**

* `after=lastMessageId`가 붙은 증분 요청은 **ETag 없이** 보내세요.

```ts
const afterParam = lastMessageIdRef.current > 0 ? `&after=${lastMessageIdRef.current}` : '';
const headers = afterParam
  ? undefined // ✅ 증분 요청엔 ETag 미사용
  : (etagRef.current ? { 'If-None-Match': etagRef.current } : undefined);

await fetch(`/api/webinars/${webinarId}/messages?limit=20${afterParam}`, {
  credentials: 'include',
  headers,
});
```

> 304로 인한 **가짜 ‘변경 없음’**을 없애서 폴백 시에도 최대한 빨리 뜨게 합니다. 

### E. 기존 채널 정리 로직 간소화

* `getChannels()`로 검색해 지우는 대신, **우리가 만든 채널만** 대상으로 정리하세요.

```ts
const ch = channelRef.current;
if (ch && ch.topic === `realtime:${channelName}`) {
  manualCloseRef.current = true;
  await ch.unsubscribe();
  supabase.removeChannel(ch);
  manualCloseRef.current = false;
}
```

> 경합을 줄이고 **본인이 아닌 채널을 실수로 닫는 일**을 막습니다. 

---

## 왜 10~15초나 걸렸나? (로그 해석)

1. 최초 SUBSCRIBED 직후, **사용자 ID 로딩 → 재구독**으로 인해 **CLOSED**가 찍히고, 이를 **실패로 카운트**합니다.
2. 이 패턴이 몇 번 반복되면 **3회 실패**로 판정 → **폴백 모드**로 전환됩니다.
3. 배포본 기준 **“10초 동안 이벤트 없음 → 폴백 활성화”** 로직이 돌아, **첫 폴까지 약 10초**, 여기에 폴 주기/지터가 더해져 **체감 10~15초**가 됩니다. 폴백 첫 요청에서 **새 메시지 1건 수신** 로그가 나오는 이유가 이것입니다. 

---

## 서버 브로드캐스트 쪽은?

* `broadcastToWebinar()`는 **service role 키**로 **관리자 클라이언트**를 만들고, 채널에 `subscribe()` 한 다음 `channel.send({ type: 'broadcast', event, payload })`로 전송합니다. 이 흐름은 정상이며, **클라이언트 지연 문제의 원인은 아님**을 로그와 코드로 확인했습니다. 

---

## 최종 체크리스트

* [ ] `CLOSED`를 실패로 더하지 않도록 **수동 종료 플래그** 도입 (A) 
* [ ] 구독 이펙트에서 **`currentUser?.id` 제거** (또는 presence는 `track()`으로 분리) (B) 
* [ ] 헬스체크를 **채널 상태 중심**으로 (C) 
* [ ] 폴백 증분 조회에선 **ETag 제거** (D) 
* [ ] **내 채널만** 정리하도록 cleanup 단순화 (E) 

위 5가지만 반영해도 **“SUBSCRIBE → 바로 CLOSED”** 루프가 멈추고, 실시간 라인이 안정화되며, 폴백으로 인한 10~15초 지연도 사실상 사라질 겁니다. 필요하시면 위 변경을 반영한 패치 형태로도 정리해 드릴게요.
